"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEntry = getEntry;
exports.getEntryUrl = getEntryUrl;
exports.setEntry = setEntry;
exports.regexRevisionNoQuotes = exports.MAX_GET_ENTRY_TIMEOUT = void 0;

var _buffer = require("buffer");

var _tweetnacl = require("tweetnacl");

var _number = require("./utils/number");

var _skylink = require("./utils/skylink");

var _string = require("./utils/string");

var _url = require("./utils/url");

var _crypto = require("./crypto");

const defaultGetEntryOptions = { ...(0, _skylink.defaultOptions)("/skynet/registry"),
  timeout: 5
};
const defaultSetEntryOptions = { ...(0, _skylink.defaultOptions)("/skynet/registry")
};
const MAX_GET_ENTRY_TIMEOUT = 300; // 5 minutes

/**
 * Regex for JSON revision value without quotes.
 */

exports.MAX_GET_ENTRY_TIMEOUT = MAX_GET_ENTRY_TIMEOUT;
const regexRevisionNoQuotes = /"revision":\s*([0-9]+)/;
/**
 * Regex for JSON revision value with quotes.
 */

exports.regexRevisionNoQuotes = regexRevisionNoQuotes;
const regexRevisionWithQuotes = /"revision":\s*"([0-9]+)"/;
/**
 * Registry entry.
 *
 * @property datakey - The key of the data for the given entry.
 * @property data - The data stored in the entry.
 * @property revision - The revision number for the entry.
 */

/**
 * Gets the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The signed registry entry.
 * @throws - Will throw if the returned signature does not match the returned entry or the provided timeout is invalid or the given key is not valid.
 */
async function getEntry(publicKey, dataKey, customOptions) {
  // Validation is done in `getEntryUrl`.
  const opts = { ...defaultGetEntryOptions,
    ...this.customOptions,
    ...customOptions
  };
  const url = this.registry.getEntryUrl(publicKey, dataKey, opts);
  let response;

  try {
    response = await this.executeRequest({ ...opts,
      url,
      method: "get",
      // Transform the response to add quotes, since uint64 cannot be accurately
      // read by JS so the revision needs to be parsed as a string.
      transformResponse: function (data) {
        if (data === undefined) {
          return {};
        } // Change the revision value from a JSON integer to a string.


        data = data.replace(regexRevisionNoQuotes, '"revision":"$1"'); // Convert the JSON data to an object.

        return JSON.parse(data);
      }
    });
  } catch (err) {
    /* istanbul ignore next */
    if (!err.response) {
      console.log("Full error: ".concat(err));
      throw new Error("Error response not found");
    }
    /* istanbul ignore next */


    if (!err.response.status) {
      console.log("Full error: ".concat(err));
      throw new Error("Error response did not contain expected field 'status'");
    } // Check if status was 404 "not found" and return null if so.


    if (err.response.status === 404) {
      return {
        entry: null,
        signature: null
      };
    }
    /* istanbul ignore next */


    if (!err.response.data) {
      console.log("Full error: ".concat(err));
      throw new Error("Error response did not contain expected field 'data'. Status code: ".concat(err.response.status));
    }
    /* istanbul ignore next */


    if (!err.response.data.message) {
      console.log("Full error: ".concat(err));
      throw new Error("Error response did not contained expected fields 'data.message'. Status code: ".concat(err.response.status));
    } // Return the error message from the response.


    throw new Error(err.response.data.message);
  } // Sanity check.


  if (typeof response.data.data !== "string" || typeof response.data.revision !== "string" || typeof response.data.signature !== "string") {
    throw new Error("Did not get a complete entry response despite a successful request. Please try again and report this issue to the devs if it persists.");
  } // Use empty string if the data is empty.


  let data = "";

  if (response.data.data) {
    data = _buffer.Buffer.from((0, _string.hexToUint8Array)(response.data.data)).toString();
  }

  const signedEntry = {
    entry: {
      datakey: dataKey,
      data,
      // Convert the revision from a string to bigint.
      revision: BigInt(response.data.revision)
    },
    signature: _buffer.Buffer.from((0, _string.hexToUint8Array)(response.data.signature))
  };

  if (signedEntry && !_tweetnacl.sign.detached.verify((0, _crypto.hashRegistryEntry)(signedEntry.entry), new Uint8Array(signedEntry.signature), (0, _string.hexToUint8Array)(publicKey))) {
    throw new Error("could not verify signature from retrieved, signed registry entry -- possible corrupted entry");
  }

  return signedEntry;
}
/**
 * Gets the registry entry URL corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full get entry URL.
 * @throws - Will throw if the provided timeout is invalid or the given key is not valid.
 */


function getEntryUrl(publicKey, dataKey, customOptions) {
  /* istanbul ignore next */
  if (typeof publicKey !== "string") {
    throw new Error("Expected parameter publicKey to be type string, was type ".concat(typeof publicKey));
  }
  /* istanbul ignore next */


  if (typeof dataKey !== "string") {
    throw new Error("Expected parameter dataKey to be type string, was type ".concat(typeof dataKey));
  }

  const opts = { ...defaultGetEntryOptions,
    ...this.customOptions,
    ...customOptions
  };
  const timeout = opts.timeout;

  if (!Number.isInteger(timeout) || timeout > MAX_GET_ENTRY_TIMEOUT || timeout < 1) {
    throw new Error("Invalid 'timeout' parameter '".concat(timeout, "', needs to be an integer between 1s and ").concat(MAX_GET_ENTRY_TIMEOUT, "s"));
  } // Trim the prefix if it was passed in.


  publicKey = (0, _string.trimPrefix)(publicKey, "ed25519:");

  if (!(0, _string.isHexString)(publicKey)) {
    throw new Error("Given public key '".concat(publicKey, "' is not a valid hex-encoded string or contains an invalid prefix"));
  }

  const query = {
    publickey: "ed25519:".concat(publicKey),
    datakey: (0, _string.toHexString)((0, _crypto.hashDataKey)(dataKey)),
    timeout
  };
  let url = (0, _url.makeUrl)(this.portalUrl, opts.endpointPath);
  url = (0, _url.addUrlQuery)(url, query);
  return url;
}
/**
 * Sets the registry entry.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param entry - The entry to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @throws - Will throw if the entry revision does not fit in 64 bits or the given key is not valid.
 */


async function setEntry(privateKey, entry, customOptions) {
  /* istanbul ignore next */
  if (typeof privateKey !== "string") {
    throw new Error("Expected parameter privateKey to be type string, was type ".concat(typeof privateKey));
  }

  if (!(0, _string.isHexString)(privateKey)) {
    throw new Error("Expected parameter privateKey to be a hex-encoded string");
  }

  if (typeof entry !== "object" || entry === null) {
    throw new Error("Expected parameter entry to be an object");
  } // Assert the input is 64 bits.


  (0, _number.assertUint64)(entry.revision);
  const opts = { ...defaultSetEntryOptions,
    ...this.customOptions,
    ...customOptions
  };
  const privateKeyArray = (0, _string.hexToUint8Array)(privateKey); // Sign the entry.

  const signature = (0, _tweetnacl.sign)((0, _crypto.hashRegistryEntry)(entry), privateKeyArray);

  const {
    publicKey: publicKeyArray
  } = _tweetnacl.sign.keyPair.fromSecretKey(privateKeyArray);

  const data = {
    publickey: {
      algorithm: "ed25519",
      key: Array.from(publicKeyArray)
    },
    datakey: (0, _string.toHexString)((0, _crypto.hashDataKey)(entry.datakey)),
    // Set the revision as a string here since the value may be up to 64 bits.
    // We remove the quotes later in transformRequest.
    revision: entry.revision.toString(),
    data: Array.from(_buffer.Buffer.from(entry.data)),
    signature: Array.from(signature)
  };
  await this.executeRequest({ ...opts,
    method: "post",
    data,
    // Transform the request to remove quotes, since the revision needs to be
    // parsed as a uint64 on the Go side.
    transformRequest: function (data) {
      // Convert the object data to JSON.
      const json = JSON.stringify(data); // Change the revision value from a string to a JSON integer.

      return json.replace(regexRevisionWithQuotes, '"revision":$1');
    }
  });
}