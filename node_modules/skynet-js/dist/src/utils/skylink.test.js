"use strict";
exports.__esModule = true;
var skylink_1 = require("./skylink");
var testing_1 = require("../../utils/testing");
var skylink = "XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg";
var skylinkBase32 = "bg06v2tidkir84hg0s1s4t97jaeoaa1jse1svrad657u070c9calq4g";
describe("convertSkylinkToBase32", function () {
    it("should convert the base64 skylink to base32", function () {
        var encoded = skylink_1.convertSkylinkToBase32(skylink);
        expect(encoded).toEqual(skylinkBase32);
    });
});
describe("formatSkylink", function () {
    it("should ensure the skylink starts with the prefix", function () {
        var prefixedSkylink = "sia:" + skylink;
        expect(skylink_1.formatSkylink(skylink)).toEqual(prefixedSkylink);
        expect(skylink_1.formatSkylink(prefixedSkylink)).toEqual(prefixedSkylink);
    });
    it("should not prepend a prefix for the empty string", function () {
        expect(skylink_1.formatSkylink("")).toEqual("");
    });
});
describe("parseSkylink", function () {
    var basicCases = testing_1.combineStrings(["", "sia:", "sia://", "https://siasky.net/", "https://foo.siasky.net/", "https://" + skylinkBase32 + ".siasky.net/"], [skylink], ["", "/", "//", "/foo", "/foo/", "/foo/bar", "/foo/bar/"], ["", "?", "?foo=bar", "?foo=bar&bar=baz"], ["", "#", "#foo", "#foo?bar"]);
    it.each(basicCases)("should extract skylink and path from %s", function (fullSkylink) {
        expect(skylink_1.parseSkylink(fullSkylink)).toEqual(skylink);
        // Check that we extract the path correctly.
        var path = testing_1.extractNonSkylinkPath(fullSkylink, skylink);
        var fullPath = "" + skylink + path;
        expect(skylink_1.parseSkylink(fullSkylink, { includePath: true })).toEqual(fullPath);
        expect(skylink_1.parseSkylink(fullSkylink, { onlyPath: true })).toEqual(path);
    });
    var subdomainCases = testing_1.combineStrings(["https://"], [skylinkBase32], [".siasky.net", ".foo.siasky.net"], ["", "/", "//", "/foo", "/foo", "/foo/", "/foo/bar", "/foo/bar/", "/" + skylink], ["", "?", "?foo=bar", "?foo=bar&bar=baz"], ["", "#", "#foo", "#foo?bar"]);
    it.each(subdomainCases)("should extract base32 skylink from %s", function (fullSkylink) {
        expect(skylink_1.parseSkylink(fullSkylink, { fromSubdomain: true })).toEqual(skylinkBase32);
        expect(skylink_1.parseSkylinkBase32(fullSkylink)).toEqual(skylinkBase32);
        // Test the fromSubdomain and onlyPath options together.
        var path = testing_1.extractNonSkylinkPath(fullSkylink, ""); // Don't need to remove the skylink from the path portion here.
        expect(skylink_1.parseSkylink(fullSkylink, { fromSubdomain: true, onlyPath: true })).toEqual(path);
    });
    it("should return null on invalid skylink", function () {
        // @ts-expect-error we only check this use case in case someone ignores typescript typing
        expect(function () { return skylink_1.parseSkylink(); }).toThrowError("Skylink has to be a string, undefined provided");
        // @ts-expect-error we only check this use case in case someone ignores typescript typing
        expect(function () { return skylink_1.parseSkylink(123); }).toThrowError("Skylink has to be a string, number provided");
    });
    var invalidCases = ["123", skylink + "xxx", skylink + "xxx/foo", skylink + "xxx?foo"];
    it.each(invalidCases)("should return null on invalid case %s", function (fullSkylink) {
        expect(skylink_1.parseSkylink(fullSkylink)).toBeNull();
    });
    it("should return null on invalid base32 subdomain", function () {
        var badUrl = "https://" + skylinkBase32 + "xxx.siasky.net";
        expect(skylink_1.parseSkylink(badUrl, { fromSubdomain: true })).toBeNull();
    });
    it("should reject invalid combinations of options", function () {
        expect(function () {
            skylink_1.parseSkylink("test", { includePath: true, onlyPath: true });
        }).toThrow();
        expect(function () {
            skylink_1.parseSkylink("test", { includePath: true, fromSubdomain: true });
        }).toThrow();
    });
});
