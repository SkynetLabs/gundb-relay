"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trimForwardSlash = trimForwardSlash;
exports.trimPrefix = trimPrefix;
exports.trimSuffix = trimSuffix;
exports.trimUriPrefix = trimUriPrefix;
exports.stringToUint8Array = stringToUint8Array;
exports.hexToUint8Array = hexToUint8Array;
exports.isHexString = isHexString;
exports.toHexString = toHexString;

/**
 * Removes a prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @returns - The processed string.
 */
function trimForwardSlash(str) {
  return trimPrefix(trimSuffix(str, "/"), "/");
}
/**
 * Removes a prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @returns - The processed string.
 */


function trimPrefix(str, prefix) {
  while (str.startsWith(prefix)) {
    str = str.slice(prefix.length);
  }

  return str;
}
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @returns - The processed string.
 */


function trimSuffix(str, suffix) {
  while (str.endsWith(suffix)) {
    str = str.substring(0, str.length - suffix.length);
  }

  return str;
}
/**
 * Removes a URI prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @returns - The processed string.
 */


function trimUriPrefix(str, prefix) {
  const longPrefix = "".concat(prefix, "//");

  if (str.startsWith(longPrefix)) {
    // longPrefix is exactly at the beginning
    return str.slice(longPrefix.length);
  }

  if (str.startsWith(prefix)) {
    // else prefix is exactly at the beginning
    return str.slice(prefix.length);
  }

  return str;
}
/**
 * Converts a string to a uint8 array.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a string.
 */


function stringToUint8Array(str) {
  /* istanbul ignore next */
  if (typeof str !== "string") {
    throw new Error("Expected parameter str to be type string, was type ".concat(typeof str));
  }

  return Uint8Array.from(Buffer.from(str));
}
/**
 * Converts a hex encoded string to a uint8 array.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a valid hex-encoded string or is an empty string.
 */


function hexToUint8Array(str) {
  if (!isHexString(str)) {
    throw new Error("Input string '".concat(str, "' is not a valid hex-encoded string"));
  }

  const matches = str.match(/.{1,2}/g);

  if (matches === null) {
    throw new Error("Input string '".concat(str, "' is not a valid hex-encoded string"));
  }

  return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
}
/**
 * Returns true if the input is a valid hex-encoded string.
 *
 * @param str - The input string.
 * @returns - True if the input is hex-encoded.
 * @throws - Will throw if the input is not a string.
 */


function isHexString(str) {
  /* istanbul ignore next */
  if (typeof str !== "string") {
    throw new Error("Expected parameter str to be type string, was type ".concat(typeof str));
  }

  return /^[0-9A-Fa-f]*$/g.test(str);
}
/**
 * Convert a byte array to a hex string.
 *
 * @param byteArray - The byte array to convert.
 * @returns - The hex string.
 * @see {@link https://stackoverflow.com/a/44608819|Stack Overflow}
 */


function toHexString(byteArray) {
  let s = "";
  byteArray.forEach(function (byte) {
    s += ("0" + (byte & 0xff).toString(16)).slice(-2);
  });
  return s;
}