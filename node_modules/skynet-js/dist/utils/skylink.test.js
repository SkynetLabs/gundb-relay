"use strict";

var _skylink = require("./skylink");

var _testing = require("../../utils/testing");

const skylink = "XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg";
const skylinkBase32 = "bg06v2tidkir84hg0s1s4t97jaeoaa1jse1svrad657u070c9calq4g";
describe("convertSkylinkToBase32", () => {
  it("should convert the base64 skylink to base32", () => {
    const encoded = (0, _skylink.convertSkylinkToBase32)(skylink);
    expect(encoded).toEqual(skylinkBase32);
  });
});
describe("formatSkylink", () => {
  it("should ensure the skylink starts with the prefix", () => {
    const prefixedSkylink = "sia:".concat(skylink);
    expect((0, _skylink.formatSkylink)(skylink)).toEqual(prefixedSkylink);
    expect((0, _skylink.formatSkylink)(prefixedSkylink)).toEqual(prefixedSkylink);
  });
  it("should not prepend a prefix for the empty string", () => {
    expect((0, _skylink.formatSkylink)("")).toEqual("");
  });
});
describe("parseSkylink", () => {
  const basicCases = (0, _testing.combineStrings)(["", "sia:", "sia://", "https://siasky.net/", "https://foo.siasky.net/", "https://".concat(skylinkBase32, ".siasky.net/")], [skylink], ["", "/", "//", "/foo", "/foo/", "/foo/bar", "/foo/bar/"], ["", "?", "?foo=bar", "?foo=bar&bar=baz"], ["", "#", "#foo", "#foo?bar"]);
  it.each(basicCases)("should extract skylink and path from %s", fullSkylink => {
    expect((0, _skylink.parseSkylink)(fullSkylink)).toEqual(skylink); // Check that we extract the path correctly.

    const path = (0, _testing.extractNonSkylinkPath)(fullSkylink, skylink);
    const fullPath = "".concat(skylink).concat(path);
    expect((0, _skylink.parseSkylink)(fullSkylink, {
      includePath: true
    })).toEqual(fullPath);
    expect((0, _skylink.parseSkylink)(fullSkylink, {
      onlyPath: true
    })).toEqual(path);
  });
  const subdomainCases = (0, _testing.combineStrings)(["https://"], [skylinkBase32], [".siasky.net", ".foo.siasky.net"], ["", "/", "//", "/foo", "/foo", "/foo/", "/foo/bar", "/foo/bar/", "/".concat(skylink)], ["", "?", "?foo=bar", "?foo=bar&bar=baz"], ["", "#", "#foo", "#foo?bar"]);
  it.each(subdomainCases)("should extract base32 skylink from %s", fullSkylink => {
    expect((0, _skylink.parseSkylink)(fullSkylink, {
      fromSubdomain: true
    })).toEqual(skylinkBase32);
    expect((0, _skylink.parseSkylinkBase32)(fullSkylink)).toEqual(skylinkBase32); // Test the fromSubdomain and onlyPath options together.

    const path = (0, _testing.extractNonSkylinkPath)(fullSkylink, ""); // Don't need to remove the skylink from the path portion here.

    expect((0, _skylink.parseSkylink)(fullSkylink, {
      fromSubdomain: true,
      onlyPath: true
    })).toEqual(path);
  });
  it("should return null on invalid skylink", () => {
    // @ts-expect-error we only check this use case in case someone ignores typescript typing
    expect(() => (0, _skylink.parseSkylink)()).toThrowError("Skylink has to be a string, undefined provided"); // @ts-expect-error we only check this use case in case someone ignores typescript typing

    expect(() => (0, _skylink.parseSkylink)(123)).toThrowError("Skylink has to be a string, number provided");
  });
  const invalidCases = ["123", "".concat(skylink, "xxx"), "".concat(skylink, "xxx/foo"), "".concat(skylink, "xxx?foo")];
  it.each(invalidCases)("should return null on invalid case %s", fullSkylink => {
    expect((0, _skylink.parseSkylink)(fullSkylink)).toBeNull();
  });
  it("should return null on invalid base32 subdomain", () => {
    const badUrl = "https://".concat(skylinkBase32, "xxx.siasky.net");
    expect((0, _skylink.parseSkylink)(badUrl, {
      fromSubdomain: true
    })).toBeNull();
  });
  it("should reject invalid combinations of options", () => {
    expect(() => {
      (0, _skylink.parseSkylink)("test", {
        includePath: true,
        onlyPath: true
      });
    }).toThrow();
    expect(() => {
      (0, _skylink.parseSkylink)("test", {
        includePath: true,
        fromSubdomain: true
      });
    }).toThrow();
  });
});