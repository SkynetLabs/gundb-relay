"use strict";

var _skylink = require("./skylink");

var _string = require("./string");

const hnsLink = "doesn";
const hnsresLink = "doesn";
expect.extend({
  // source https://stackoverflow.com/a/60818105/6085242
  toEqualUint8Array(received, argument) {
    if (received.length !== argument.length) {
      return {
        pass: false,
        message: () => "expected ".concat(received, " to equal ").concat(argument)
      };
    }

    for (let i = 0; i < received.length; i++) {
      if (received[i] !== argument[i]) {
        return {
          pass: false,
          message: () => "expected ".concat(received, " to equal ").concat(argument)
        };
      }
    }

    return {
      pass: true,
      message: () => "expected ".concat(received, " not to equal ").concat(argument)
    };
  }

});
describe("hexToUint8Array", () => {
  const hexStrings = [["ff", [255]], ["a", [10]], ["ff0a", [255, 10]]];
  it.each(hexStrings)("the hex string '%s' should be decoded to %s", (str, array) => {
    const byteArray = (0, _string.hexToUint8Array)(str);
    expect(byteArray).toEqualUint8Array(new Uint8Array(array));
  });
  const invalidHexStrings = ["xyz", "aabbzz", ""];
  it.each(invalidHexStrings)("should throw on invalid input '%s'", str => {
    expect(() => (0, _string.hexToUint8Array)(str)).toThrowError("Input string '".concat(str, "' is not a valid hex-encoded string"));
  });
});
describe("trimUriPrefix", () => {
  it("should correctly parse hns prefixed link", () => {
    const validHnsLinkVariations = [hnsLink, "hns:".concat(hnsLink), "hns://".concat(hnsLink)];
    const validHnsresLinkVariations = [hnsresLink, "hnsres:".concat(hnsresLink), "hnsres://".concat(hnsresLink)];
    validHnsLinkVariations.forEach(input => {
      expect((0, _string.trimUriPrefix)(input, _skylink.uriHandshakePrefix)).toEqual(hnsLink);
    });
    validHnsresLinkVariations.forEach(input => {
      expect((0, _string.trimUriPrefix)(input, _skylink.uriHandshakeResolverPrefix)).toEqual(hnsresLink);
    });
  });
});