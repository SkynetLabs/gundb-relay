"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeNumber = encodeNumber;
exports.encodeBigintAsUint64 = encodeBigintAsUint64;
exports.encodeString = encodeString;
exports.deriveChildSeed = deriveChildSeed;
exports.genKeyPairAndSeed = genKeyPairAndSeed;
exports.genKeyPairFromSeed = genKeyPairFromSeed;
exports.hashAll = hashAll;
exports.hashDataKey = hashDataKey;
exports.hashRegistryEntry = hashRegistryEntry;

var _sjcl = require("sjcl");

var _blakejs = require("blakejs");

var _randombytes = _interopRequireDefault(require("randombytes"));

var _tweetnacl = require("tweetnacl");

var _number = require("./utils/number");

var _string = require("./utils/string");

/**
 * Returns a blake2b 256bit hasher. See `NewHash` in Sia.
 *
 * @returns - blake2b 256bit hasher.
 */
function newHash() {
  return (0, _blakejs.blake2bInit)(32, null);
}
/**
 * Converts the given number into a uint8 array
 *
 * @param num - Number to encode.
 * @returns - Number encoded as a byte array.
 */


function encodeNumber(num) {
  const encoded = new Uint8Array(8);

  for (let index = 0; index < encoded.length; index++) {
    const byte = num & 0xff;
    encoded[index] = byte;
    num = num >> 8;
  }

  return encoded;
}
/**
 * Converts the given bigint into a uint8 array.
 *
 * @param int - Bigint to encode.
 * @returns - Bigint encoded as a byte array.
 * @throws - Will throw if the int does not fit in 64 bits.
 */


function encodeBigintAsUint64(int) {
  // Assert the input is 64 bits.
  (0, _number.assertUint64)(int);
  const encoded = new Uint8Array(8);

  for (let index = 0; index < encoded.length; index++) {
    const byte = int & BigInt(0xff);
    encoded[index] = Number(byte);
    int = int >> BigInt(8);
  }

  return encoded;
}
/**
 * Converts the given string into a uint8 array.
 *
 * @param str - String to encode.
 * @returns - String encoded as a byte array.
 */


function encodeString(str) {
  const encoded = new Uint8Array(8 + str.length);
  encoded.set(encodeNumber(str.length));
  encoded.set((0, _string.stringToUint8Array)(str), 8);
  return encoded;
}
/**
 * Derives a child seed from the given master seed and sub seed.
 *
 * @param masterSeed - The master seed to derive from.
 * @param seed - The sub seed for the derivation.
 * @returns - The child seed derived from `masterSeed` using `seed`.
 * @throws - Will throw if the inputs are not strings.
 */


function deriveChildSeed(masterSeed, seed) {
  /* istanbul ignore next */
  if (typeof masterSeed !== "string") {
    throw new Error("Expected parameter masterSeed to be type string, was type ".concat(typeof masterSeed));
  }
  /* istanbul ignore next */


  if (typeof seed !== "string") {
    throw new Error("Expected parameter seed to be type string, was type ".concat(typeof seed));
  }

  return (0, _string.toHexString)(hashAll(encodeString(masterSeed), encodeString(seed)));
}
/**
 * Generates a master key pair and seed.
 *
 * @param [length=64] - The number of random bytes for the seed. Note that the string seed will be converted to hex representation, making it twice this length.
 * @returns - The generated key pair and seed.
 */


function genKeyPairAndSeed(length = 64) {
  const seed = makeSeed(length);
  return { ...genKeyPairFromSeed(seed),
    seed
  };
}
/**
 * Generates a public and private key from a provided, secure seed.
 *
 * @param seed - A secure seed.
 * @returns - The generated key pair.
 * @throws - Will throw if the input is not a string.
 */


function genKeyPairFromSeed(seed) {
  /* istanbul ignore next */
  if (typeof seed !== "string") {
    throw new Error("Expected parameter seed to be type string, was type ".concat(typeof seed));
  } // Get a 32-byte key.


  const derivedKey = _sjcl.misc.pbkdf2(seed, "", 1000, 32 * 8);

  const derivedKeyHex = _sjcl.codec.hex.fromBits(derivedKey);

  const {
    publicKey,
    secretKey
  } = _tweetnacl.sign.keyPair.fromSeed((0, _string.hexToUint8Array)(derivedKeyHex));

  return {
    publicKey: (0, _string.toHexString)(publicKey),
    privateKey: (0, _string.toHexString)(secretKey)
  };
}
/**
 * Takes all given arguments and hashes them.
 *
 * @param args - Byte arrays to hash.
 * @returns - The final hash as a byte array.
 */


function hashAll(...args) {
  const hasher = newHash();

  for (let i = 0; i < args.length; i++) {
    (0, _blakejs.blake2bUpdate)(hasher, args[i]);
  }

  return (0, _blakejs.blake2bFinal)(hasher);
}
/**
 * Hash the given data key.
 *
 * @param datakey - Datakey to hash.
 * @returns - Hash of the datakey.
 */


function hashDataKey(datakey) {
  return hashAll(encodeString(datakey));
}
/**
 * Hashes the given registry entry.
 *
 * @param registryEntry - Registry entry to hash.
 * @returns - Hash of the registry entry.
 */


function hashRegistryEntry(registryEntry) {
  return hashAll(hashDataKey(registryEntry.datakey), encodeString(registryEntry.data), encodeBigintAsUint64(registryEntry.revision));
}
/**
 * Generates a random seed of the given length in bytes.
 *
 * @param length - Length of the seed in bytes.
 * @returns - The generated seed.
 */


function makeSeed(length) {
  // Cryptographically-secure random number generator. It should use the
  // built-in crypto.getRandomValues in the browser.
  const array = (0, _randombytes.default)(length);
  return (0, _string.toHexString)(array);
}